<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[剑指offer(2)]]></title>
    <url>%2F2020%2F01%2F22%2FJava%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F%E5%89%91%E6%8C%87offer(2)%2F</url>
    <content type="text"><![CDATA[请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。 123456789101112131415161718192021222324252627282930313233343536public class Solution &#123; public String replaceSpace(StringBuffer str) &#123; String str1 = str.toString(); if(str1.equals(&quot;&quot;)) &#123; return(str1); &#125; char [] strArray = str1.toCharArray(); int lengthSpace = 0; for(int i = 0;i&lt;strArray.length;i++) &#123; if(strArray[i]==&apos; &apos;) &#123; lengthSpace++; &#125; &#125; int newStrLength = strArray.length + lengthSpace*2; char [] newstrArray = new char[newStrLength]; int count = 0; for(int i = 0;i&lt;strArray.length;i++) &#123; if(strArray[i]!=&apos; &apos;) &#123; newstrArray[i+count*2] = strArray[i]; &#125; else&#123; newstrArray[i+2*count]=&apos;%&apos;; newstrArray[i+2*count+1]=&apos;2&apos;; newstrArray[i+2*count+2]=&apos;0&apos;; count++; &#125; &#125; return new String(newstrArray); &#125;&#125; 12345public class Solution &#123;public String replaceSpace(StringBuffer str) &#123;return str.toString().replaceAll(&quot;\\s&quot;, &quot;%20&quot;);&#125;&#125; 题解：如果建新数组的话，从后往前还是从前往后都是一样的。??? charAt(),deleteCharAt() s1.charAt(3); s1.deleteCharAt(3); setCharAt();替换所引出的char值 str.setCharAt(indexnew, ‘0’); append(); StringBuffer s1 = new StringBuffer().append(“bbb”); s1.append(“aaa”); System.out.println(s1.toString()); replace两种用法： replace(int start，int end, String str)replace(char oldchar, char newchar) toString() toCharArray() StringBuffer s1 = new StringBuffer();s1.toString();String s2 = new String();s2.toCharArray(); delete(); insert(); indexOf(); lastIndexOf(); reverse(); length();indexOf()返回指定字符串的开始字符索引位置，还可以从某个字符索引位置开始向后匹配，没有找到匹配的就会返回-1lastIndexOf()是从后往前匹配，也支持从指定索引开始从后往前去匹配 s1.delete(2,4);s1.insert(2,”cc”);System.out.println(s1.indexOf(“ba”));System.out.println(s1.indexOf(“ba”,2));System.out.println(s1.reverse());System.out.println(s1.length()); String,StringBuffer,StringBuilder三者的使用方法和区别String适用于少量的字符串操作的情况StringBuilder适用于单线程下在字符缓冲区进行大量操作的情况StringBuffer适用多线程下在字符缓冲区进行大量操作的情况 一.java数据类型1.基本数据类型byte(1) boolean(1) short(2) char(2) int(4) float(4) long(8)double (8)2.引用数据类型string,数组，集合ArrayList,Scanner,Random,自定义类型3.引用类型String中的方法第一组：判断方法boolean equals(String str); //比较两个字符串是否相等boolean equalsIgnoreCase(String str); //比较两个内容是否相等 （忽略大小写）boolean startsWith(String subStr); //判断某个字符串是否以指定的子串开头boolean endsWith(String subStr); //判断某个字符串是否以指定的子串结尾第二组：获取方法int length();//获取字符串中字符个数char charAt(int index); //获取字符串中某一个字符String substring(int startIndex);//从指定下标开始截取字符串，直到字符串结尾substring(int startIndex,int endIndex); //包括开头不包括结尾？int indexof(String subStr); //获取子串第一次出现的下标第三组：转换方法String toLowerCase(); //转成小写串String toUpperCase); //转成大写串Char[] toCharArray(); //变成字符数组第四组：其他方法String trim();//去掉字符串两端的空格String[] split(String str); //切割字符串三：读写文件输出流：数据从java程序 到 文件中FilWriter：文件的字符输出流，写数据 （一个字符，一个字符串，一个字符数组） write(int ch);// 写一个字符 write(char[] chs); //写一个字符数组 write(String s);// 写一个字符串 write(char[] chs,int startInex,int len);// 写一个字符数组的一部分 write(String s,int startInex,int len); //写一个字符串的一部分输入流：数据从文件 到 java程序中FileReader:文件的字符输入流,读数据（一个字符，一个字符数组） int read();//读取一个字符 ASCII int read(char[] chs); //一次读取一个字符数组，返回值是读取的字符的个数文件的路径分为两种：1.相对路径：相对于当前项目而言的 2.绝对路径：以盘符开头]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础学习1]]></title>
    <url>%2F2020%2F01%2F04%2FJava%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2Fjava%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01%2F</url>
    <content type="text"><![CDATA[类的概念： 一堆具有共同的成员变量、属性和成员方法、功能对象集合 接口的概念： 接口是功能的集合，就是方法的集合 也就是说 接口中只能定义方法，不能定义普通的成员变量 而且接口中的成员方法，必须都是抽象的 接口是比抽象类还要抽象的一种类型 问题：接口能创建对象吗？不能接口作用：天生作为“父接口” 接口的定义： 定义接口用关键字：interface 定义枚举用关键字：enum 格式： public interface 接口名字{ //成员变量，不能定义普通的成员变量 //成员方法：必须都是抽象 public abstract 返回值类型 方法名(); } 类和接口的本质区别不大，他们的源码都是.java文件 编译后都是.class文件 类与类之间：继承，而且是单继承，一个子类，只能有一个直接父类 接口和接口之间:继承，但是可以多继承，一个子接口 可以有多个直接父接口 面试题：Java到底支不支持多继承？ 如果是类与类 不支持多继承 只支持多层继承 如果是接口和接口 支持多继承 也支持多层继承 类和接口之间：不叫继承(extends),叫实现(implements),可以多实现 只有类 实现接口 接口中成员的特点 5.1成员变量，但是必须有固定修饰符public static final 数据类型 变量 = 值 5.2成员方法，必须是固定修饰符public abstract 即抽象方法 5.3接口不可以创建对象(抽象类也是) 5.4实现类 实现类接口，那么必须重写接口中所有的抽象方法，然后才能创建对象否则 这个实现类 还是一个抽象类，是不能创建对象的 在开发中最常用的模式： public class A extends AbstractClassB implements 接口A，接口B{ 注意： A中必须重写 抽象类中的抽象方法，以及所有接口中的抽象方法 } 接口和抽象类的异同：1.相同点： a.都不能创建对象 b.都是作为父类/父接口 c.子类/实现类 都必须重写抽象方法，然后才能创建对象2.不同点： a.抽象类用关键字abstract 接口用关键字interface b.接口中只要有方法，必须都是抽象的 c.抽象类可以定义任意成员变量 接口的成员变量必须public static final修饰 d.类和抽象类之间关系是单继承，类和接口之间关系是多实现 e.思想上的区别 1.抽象类中必须定义整个继承体系中的共性内容 2.接口中定义 整个继承体系之外的 额外扩展的功能。 7.面向对象3大特征：封装(安全性)，继承(扩展性)，多态(灵活性) 多态： 前提1.必须有子父类关系 2.必须有方法的重写 多态在Java中的表现形式： 父类类型 变量名 = new 子类类型(); 接口类型 变量名 = new 实现类(); Animal an = new Cat(); 父类类型的变量指向了子类的对象 注意： 1.使用多态调用成员变量 编译时，看父类 运行时，看父类 2.使用多态调用成员方法 编译时，看父类 运行时，看子类总结： 弊端：多态只能调用子父类共有的方法，不能调用子类特有的方法 好处：提高灵活性 父类类型的变量，可以接收任何一个子类的对象 调用方法的时候，编译是看父类，运行时运行的传递过来的子类对象的方法 弊端的解决方案： 向下转型：强制类型转换 向上转型：自动类型转换 (就是多态) 向下转型也有弊端： 把父类的变量 转成任何子类类型时候，编译器直接通过 可以转成cat,本质是dog 所以出错 Java中解决向下转型弊端的方法： 一个关键字Instanceof 运算符 作用：判断某一个变量 不是 该类的类型 格式： boolean b = an instanceof 类名 多态提高程序的灵活性，扩展性，复用性。 static的介绍: static的作用用来修饰类中的成员 1.如果一个类的成员被static修饰了，怎么访问？ 类名.成员变量名 存在方法区中的静态区，只有一个空间 优先于对象存在 2.类名.成员变量(推荐) 对象.成员变量 都可以 3.所有对象共有的，被staic修饰的成员属于类，不属于单个对象 4.静态没有多态性 静态不属于对象，属于类 5.静态代码块：在类的成员位置 static{ 代码 } 特点： 使用到这个类时，JVM会自动执行静态代码块 只会第一次使用时执行 优先级比构造方法高，比main方法高 作用：用来初始化类的,myswl数据(静态代码块来加载驱动) final可以修饰 类，成员变量，成员方法，局部变量(基本类型，引用类型) 1.修饰类(太监类)，不能被继承 2.final修饰成员变量: 2.1必须在创建对象之前有却确定的值 2.3只能赋值一次 3.修饰方法: 不能被子类重写 4.修饰基本类型局部变量 被final修饰的基本类型局部变量 只能赋值一次 5.修饰引用类型局部变量 被final修饰的引用类型局部变量 只能赋值一次 但是引用类型所指向的对象中内容是可以改变的 匿名内部类：是一种特殊的语法，用来快速创建抽象类的子类对象 用来快速创建 接口的实现类对象 AbstractAnimal an1 = new AbstractAnimal(){ 重写 } 多态 引用数据类型a.类作为方法的参数或者返回值(我们需要传递或返回的是该类的对象)b.抽象类作为方法的参数和返回值 (和9结合起来)我们需要传递或返回的是该抽象类的子类的对象c.接口作为方法的参数和返回值 (我们需要传递或返回的是该接口的实现类的对象) 链式编程 权限修饰符如果一个成员只想在本类中使用 用private修饰如果一个成员想在本类和本包的其它类中使用 不写 default如果一个成员想在本类，本包，其他包的子类中使用 用protected修饰如果一个成员想在所有类中使用 用public修饰 Object类：类Object是类层次结构的根类所有类都必须直接或者间接的继承object boolean equals(Object obj);p1.equals(p2);//比较两个对象是否相等,在Object类中定义equals方法比较是 两个对象的地址在String类中 重写了object父类中的equals方法， 本来在object类中比较的是两个对象的地址 在String重写后变成比较两个字符串的内容 我们程序员 通常自定义一个类 也会重写equals toString(); //返回该对象的字符串表示 Object类中的默认的返回值：包名.类名@地址 实际开发中toString的使用，重写toString 返回对象中的成员变量 异常:是java代码编译或者运行过程中异常的继承体系:Throwable(异常和错误的超类):可以抛出去的东西 --Exception:异常(普通问题) --编译时异常: 指的是Exception 以及Exception子类 (除了RuntimeException) --运行时异常: RuntimeException以及其子类 --Error:错误(严重问题) 比如:OutOfMemoryError:超出内存错误 如果程序出现了错误，只能改代码 创建异常对象，对异常的基本操作：1.抛出异常 2.处理异常(捕获异常，将异常获取，使用try/catch做分支处理)JVM默认处理异常的方式:(中断处理)处理异常的方式：1.不处理 public 返回值类型 方法名(参数)throws xxxException{ } 2.捕获处理 try{ 可能出现的异常的代码 }catch(Exception e){ //处理异常 }finally{ //写上必须要执行的代码 //释放资源的代码 } 3.其他的处理方式 多个异常分别处理 多个个异常一次捕获多次处理 多个异常一次捕获一次处理 父类方法没有抛出异常，子类覆盖父类该方法时也不可抛出异常。此时子类产生该异常，只能捕获处理。打印异常信息:printStackTrace1.RuntimeException2.ClassCastException 类型转换异常(向下转型的时候)3.ArrayIndexOutOfBoundsException 数组下标越界4.StringIndexOutOfBoundsException 字符串下标越界自定义异常类：1.创建一个类，这个类必须用Exception结尾2.必须继承Exception 或者 RumtimeException3.自定义的异常 至少有两个构造 a.空参数构造 b.带有String类型参数构造 Object类:是所有类的根类boolean equals(Object obj)a.Object类中equals方法,比较是两个对象的地址，就是==号的作用b.重写 比较两个字符串的内容 比较两个对象的成员变量的值String toString();//返回该对象的字符串表示 hashCode()返回该对象的数字表示 什么叫设计模式？把解决问题的方案 总结出一个套路1.代理设计模式1.1静态代理设计模式1.2动态代理设计模式 date类:日期类表示特定的瞬间，精确到毫秒 public Date(); //无参构造public Date(long time);1.DateFormat是一个抽象类 我们不能用它2.我们使用它的一个子类：SimpleDateFormatSimpleDateFormat:简单的日期格式化类1.构造public SimpleDateFormat(String pattern);//以指定的模式 创建一个日期格式化对象 2.成员方法public String format(Date d);//格式化一个日期对象，返回格式化后的一个字符串 public Date parse(String s);//把一个字符串形式的日期，解析成Date对象 Calender类获取Calendar的子类对象获取Calender对象的某个字段 (get) System类它不能被实例化，因为构造方法私有化了而且System类中的方法都是静态的，通过类名就可以直接访问System.exit(0); //退出JVMpublic static void gc(); //运行java的垃圾回收器(并不是马上运行)public static String getProperty(String ProertyName);//获取某一个属性的值public static long currentTimeMillis();//获取当前系统的毫秒值 String(不可变) StringBuilder(可变)//当出现大量的字符串拼接运算 时 用StringBuilder 基本数据类型 对应的引用类型int Integer拆箱：包装类型—&gt;基本类型装箱：基本类型—&gt;包装类型 正则表达式： javac 生成编译文件 java 执行类文件，出错原因java程序运行class文件,对于有包名的类,java把包名当成文件夹处理.”包名+类名”相当于”文件夹目录+类名”来寻找类。 b = a++ a先赋值，再自增。 mysql Orcale DB2(银行系统) SQLite(手机端) SQLServer SyBase(建模工具PowerDesigner)]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[考研]]></title>
    <url>%2F2019%2F03%2F24%2F%E8%80%83%E7%A0%94%2F</url>
    <content type="text"><![CDATA[失败不是终点，找好工作再说8]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汇编语言]]></title>
    <url>%2F2019%2F02%2F25%2F%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%2F</url>
    <content type="text"><![CDATA[指令系统数据寻址方式: CPU: 立即寻址方式 寄存器寻址方式 存储器： 直接寻址方式 间接寻址方式 相对寻址方式]]></content>
  </entry>
  <entry>
    <title><![CDATA[python爬虫初学]]></title>
    <url>%2F2019%2F02%2F09%2Fpython%E7%88%AC%E8%99%AB%E5%88%9D%E5%AD%A6%2F</url>
    <content type="text"><![CDATA[#coding:utf-8 #author:Ericam_ 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344import reimport sysfrom bs4 import BeautifulSoupimport urllib.requestimport timeheaders = (&apos;User-Agent&apos;, &apos;Mozilla/5.0 (iPhone; CPU iPhone OS 9_1 like Mac OS X) AppleWebKit/601.1.46 (KHTML, like Gecko) Version/9.0 Mobile/13B143 Safari/601.1&apos;)opener = urllib.request.build_opener()opener.addheaders = &#123;headers&#125;urllib.request.install_opener(opener)def get_download(url): file = urllib.request.urlopen(url) data = BeautifulSoup(file , from_encoding=&quot;utf8&quot;) section_name = data.title.string print(section_name) section_text = data.select(&apos;#content #left font&apos;)[0].text section_text=re.sub( &apos;\s+&apos;, &apos;\r\n\t&apos;, section_text).strip(&apos;\r\n&apos;) fp = open(&quot;D:/python/2.txt&quot;,&apos;a&apos;,encoding=&apos;utf-8&apos;) fp.write(section_name+&apos;\n&apos;) fp.write(section_text+&apos;\n&apos;) fp.close()if __name__ == &apos;__main__&apos;: url = &quot;http://www.net767.com/shuji/fubaba/10995.html&quot; while(True): file = urllib.request.urlopen(url) data = BeautifulSoup(file , from_encoding=&quot;utf8&quot;) section_name = data.title.string print(section_name) section_text = data.select(&apos;#content #left font&apos;)[0].text section_text=re.sub( &apos;\s+&apos;, &apos;\r\n\t&apos;, section_text).strip(&apos;\r\n&apos;) print(section_text) txt_section=data.select(&apos;#pagebar a&apos;) l1=len(txt_section) for num in range(1,l1-1): y=txt_section[num][&apos;href&apos;] url = &quot;http://www.net767.com&quot;+y get_download(url) print(y) txt2_section=data.select(&apos;.LinkNextArticle&apos;) y2=txt2_section[0][&apos;href&apos;] url = &quot;http://www.net767.com&quot;+y2 if(url == &apos;http://www.net767.com/shuji/fubaba/11003_9.html&apos;): break print(y2)]]></content>
  </entry>
  <entry>
    <title><![CDATA[Java学习笔记2]]></title>
    <url>%2F2019%2F02%2F08%2FJava%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[项目（秒杀系统） 集合： 数组的长度是固定的，集合的长度是可变的。 每一个容器的数据结构不一样 Collection接口定义着集合框架中最最共性的内容]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript学习笔记]]></title>
    <url>%2F2019%2F01%2F21%2Fjavascript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[参考菜鸟教程进行学习 javascript用法：HTML 中的脚本必须位于 与 标签之间。脚本可被放置在 HTML 页面的 和 部分中，也可以保存在外部文件中（则不需要加标签）。 输出： 使用 window.alert() 弹出警告框。 使用 document.write() 方法将内容写到 HTML 文档中。 使用 innerHTML 写入到 HTML 元素。 使用 console.log() 写入到浏览器的控制台。 var y; var z; var d; x=document.getElementsByClassName("Barrage-listItem"); y=document.getElementById(x[0].id); d=y.getElementsByTagName("div"); var reg = /Barrage-userEnter/i; console.log(reg.test(d[0].className)); console.log(d[0].className); if(reg.test(d[0].className)) { z=y.getElementsByTagName("span"); console.log(z[2].title); d[0].className="b"; }]]></content>
  </entry>
  <entry>
    <title><![CDATA[个人随笔]]></title>
    <url>%2F2019%2F01%2F20%2F%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94%2F</url>
    <content type="text"><![CDATA[1月20记 好久没有写日记了，下午和从小长大的朋友聊了会天，真的感觉时间过的好快。而且似乎到了什么年龄，周围的人就会询问关心你这个年龄应该干的事情做的怎么样。就好像上学期间就是学校的好坏，工作期间就是结婚工资。那么究竟你是变得更好还是会更烂呢？ 考研信息，结课作业。1.21到1.25 英语单词，阅读。寒假每天坚持 线代复习，真题。寒假每天坚持视频每天3个，加看辅导书。 javascrip,css,html。 python,爬虫项目。 1.28到2.2 实验室论文，深度学习。 2.2以后 小程序项目 1.28到2.2 java 2.2以后前三个尽量做完，4，5，7完成一二即可，6，8能入门就再好不过了。 其他： 旅游（估计难了 555） 联系一下朋友同学 （加油嗷） 吃饭，作息规律 （一定可以的） 读完3本书 (穷爸爸，富爸爸 如何阅读一本书 自控力) 想到的再继续补充~ 2.8到2.20（11天） 线代每天两个视频，辅导讲义写完 3 英语一个单元 2.5（课听完） 看书1个小时 查考研信息 问问问 健身刷牙 python斗鱼的项目 小程序的项目 #抛弃浮躁，脚踏实地。 英语： 单词： 高频单词视频看完 （2月之前） 每天1个list背诵 空闲时间刷百词斩 阅读： 3.4月份：08年之前的真题阅读精读（一天一篇）+网课学习 暂定3个小时 5，6，7 做完所有真题阅读 8，9，10 作文，翻译，完型 暂定数学： 线代： 两天一章，视频+讲义+课本看完（2月底） 暂定暑假过第二遍 高数： 3，4月刷高数18讲+书+记笔记（第一遍） 后来暂定 概率论： 5或6月份专业课： 大概确定院校！！！ 背书 真题政治： 9月份大纲确定开始 时间安排：（暂定，根据具体情况会调整） 6：30~6：40洗漱 6：40~7：00吃早饭 7：10~8：00背单词 8：00~12：00 12：00~12：20吃饭 12：20~1：10休息 1：30~4：30 4：40~5：30健身 5：30~5:50吃饭 6：00~6：20洗澡 6：30~11:00 11:00~11:30洗漱，处理部分事情，睡觉 补充： 根据上课的时间进行有效调整 最重要的是把每天的任务计划都要提前列出来并且完成 咨询考研相关信息（学校，实验室，导师，考研参考书，学习方法，有效途径，询问学长学姐老师同学）放在中午12：00~1：30，4：30~6；30，11：00以后 其他时间不要看！！！ 3.8 7点起来 洗漱，吃饭。 8点到9点背单词和句子 9点到11点看英语视频 11点去吃饭+问王伟考研学校+专业课考什么 2点到4：30点看线代视频 4：30~6：30 健身，吃饭，洗澡 6：30~10：00 高数 买参考书]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo+github搭建博客]]></title>
    <url>%2F2019%2F01%2F19%2Fhexo-github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[序 搭建博客的过程教程很多，我也是参照网上的教程搭建的博客。搭建博客已经过去半年了，但是自己这么久却没有写这篇博文，多说无益，希望能从这篇博客开始先记录hexo博客的问题以及解决方法然后能坚持下去将自己所学所见记录下来，也作为自己生活学习的一个监督和记录。 搭建步骤： GitHub创建个人仓库（名称与用户名一致） git安装，绑定github密钥 git config –global user.name “你的GitHub用户名”git config –global user.email “你的GitHub注册邮箱” 生成ssh密钥文件： ssh-keygen -t rsa -C “你的GitHub注册邮箱” 打开GitHub_Settings_keys 页面，新建new SSH Key 安装node.js，npm 安装hexo： npm install -g hexo-cli 博客初始化： hexo init blog 查看本地localhost是否成功 修改.yml站点配置文件，绑定github 绑定域名 在blog\source下新建CNAME文件（无文件名）,例如： XXX.top 域名解析：建立CNAME解析，主机名分别为@和www，对应值都是你的 Github 个人主页地址 最后hexo g,hexo d,就ok辣。 命令介绍npm install hexo -g #安装Hexonpm update hexo -g #升级hexo init #初始化博客hexo n “我的博客” == hexo new “我的博客” #新建文章hexo g == hexo generate #生成hexo s == hexo server #启动服务预览hexo d == hexo deploy #部署hexo server #Hexo会监视文件变动并自动更新，无须重启服务器hexo server -s #静态模式hexo server -p 5000 #更改端口hexo server -i 192.168.1.1 #自定义 IPhexo clean #清除缓存，若是网页正常情况下可以忽略这条命令 踩过的坑首先第一次搭建完成后，遇到了61行date的问题 ，一直没有解决，所以我选择了再次搭建，并且将此过程记录了下来。 使用hexo命令显示无效注意需要在blog文件下进行操作还有congig.yml 空格问题基本新手都会犯 执行hexo命令出现ERRORnpm install 即可 前面都没有问题到了hexo d时候连接不上git所以不应用http 应该使用git 本地命令成功 但是localhost:访问不到网址大概率是端口占用了 本地可以访问但是用户名加github.io无法访问注意库名与用户名一致!!! 下载主题出现代理的问题 查询是否使用代理： git config –global http.proxy 取消代理： git config –global –unset http.proxy ERROR Process failed: about/index.mdTypeError: Cannot read property ‘utcOffset’ of null折腾了半天发现原来站点的配置文件的timezone也就是时区必须要和主题的的配置文件一直，把这两个文件下的timezone都设为Asia/Shanghai就解决了 Cannot GET/xxx查看index.html文件是否还在，可以参考这个 附加功能： 1.打赏 准备支付宝和微信二维码 在_config.yml中配置图片 reward_comment: 坚持原创技术分享，您的支持将鼓励我继续创作！wechatpay: /images/wechat.jpgalipay: /images/aipay.png wechat.jpg、alipay.png图片放入themes/next/source/images(主题配置)中 （解决文字闪烁问题）修改next/source/css/_common/components/post/post-reward.styl，注释wechat:hover和alipay:hover]]></content>
  </entry>
</search>
