<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[hexo+github迁移电脑]]></title>
    <url>%2F2021%2F04%2F04%2Fhexo-github%E8%BF%81%E7%A7%BB%E7%94%B5%E8%84%91%2F</url>
    <content type="text"><![CDATA[hexo个人博客迁移从一台电脑上迁移至另外一台电脑 实现步骤 复制blog文件夹 在新的电脑上下载新的git和nodejs npm install 安装hexo,重新部署。问题1.nodejs版本过高 下载低版本13.14。2. Please make sure you have the correct access rights and the repository exists.（一般是公钥出问题） git config –global user.name “你的GitHub用户名”git config –global user.email “你的GitHub注册邮箱” 删除.ssh文件夹（直接搜索该文件夹）下的known_hosts(手动删除即可，不需要git） 生成ssh密钥文件： ssh-keygen -t rsa -C “你的GitHub注册邮箱” 打开GitHub_Settings_keys 页面，新建new SSH Key，把密钥复制上去。 3.遇见404问题参考解决方法]]></content>
  </entry>
  <entry>
    <title><![CDATA[markdown]]></title>
    <url>%2F2020%2F05%2F05%2Fmarkdown%2F</url>
    <content type="text"><![CDATA[空格输入 \&nbsp; 空行输入 \&emsp;]]></content>
  </entry>
  <entry>
    <title><![CDATA[正则获取词缀集]]></title>
    <url>%2F2020%2F05%2F05%2F%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[从词典中获取词缀集 代码1234567891011121314import ref = open(&quot;C:/Users/张金元/Desktop/a.txt&quot;, &quot;r&quot;, encoding=&apos;utf-8&apos;) #打开a.txt文件，以只读得方式，注意编码格式，含中文data = f.readlines() #循环文本中得每一行，得到得是一个列表的格式&lt;class &apos;list&apos;&gt;f.close() #关闭a.txt文件for line in data: result = re.findall(&apos;-(\w*\w)\s+&apos;,line) #使用正则表达式筛选每一行的数据,自行查找正则表达式 取得后缀 result1 = list(set(result)) #去掉重复后缀 result1.sort(key=result.index) #按照之前的list排序 print(&quot;res1:%s&quot; % result1)for i in result1: f1 = open(&quot;C:/Users/张金元/Desktop/c.txt&quot;, &quot;a+&quot;, encoding=&apos;utf-8&apos;) #新建一个c.txt文本，已追加的方式写入 f1.write(i + &apos;\n&apos;) # 将每一行打印进c.txt文件并换行 f1.close() # 关闭c.txt文件** print(i) python txt操作 打开文件：f = open(“test.txt”, ‘操作模式’) #”test.txt”文本操作路径 w ——————————– 只能写入，如果之前有文件，则会被覆盖 r ——————————– 只能读取 a ——————————– 向文件追加 w+ ——————————– 可读可写 r+ ——————————– 可读可写 a+ ——————————– 可读可追加 wb+ ——————————写入进制文件正则表达式语法 . 匹配任意字符（不包括换行符） ^ 匹配开始位置，多行模式下匹配每一行的开始 $ 匹配结束位置，多行模式下匹配每一行的结束 * 匹配前一个元字符0到多次 + 匹配前一个元字符1到多次 ? 匹配前一个元字符0到1次 {m,n} 匹配前一个元字符m到n次 \\ 转义字符，跟在其后的字符将失去作为特殊元字符的含义，例如\.只能匹配.，不能再匹配任意字符 [] 字符集，一个字符的集合，可匹配其中任意一个字符 | 逻辑表达式 或 ，比如 a|b 代表可匹配 a 或者 b (…) 分组，默认为捕获，即被分组的内容可以被单独取出，默认每个分组有个索引，从 1 开始，按照”(“的顺序决定索引值 (?iLmsux) 分组中可以设置模式，iLmsux之中的每个字符代表一个模式,用法参见 模式 I (?:…) 分组的不捕获模式，计算索引时会跳过这个分组 (?P…) 分组的命名模式，取此分组中的内容时可以使用索引也可以使用name (?P=name) 分组的引用模式，可在同一个正则表达式用引用前面命名过的正则 (?#…) 注释，不影响正则表达式其它部分,用法参见 模式 I (?=…) 顺序肯定环视，表示所在位置右侧能够匹配括号内正则 (?!…) 顺序否定环视，表示所在位置右侧不能匹配括号内正则 (?&lt;=…) 逆序肯定环视，表示所在位置左侧能够匹配括号内正则 (?&lt;!…) 逆序否定环视，表示所在位置左侧不能匹配括号内正则 (?(id/name)yes|no) 若前面指定id或name的分区匹配成功则执行yes处的正则，否则执行no处的正则 \number 匹配和前面索引为number的分组捕获到的内容一样的字符串 \A 匹配字符串开始位置，忽略多行模式 \Z 匹配字符串结束位置，忽略多行模式 \b 匹配位于单词开始或结束位置的空字符串 \B 匹配不位于单词开始或结束位置的空字符串 \d 匹配一个数字， 相当于 [0-9] \D 匹配非数字,相当于 [^0-9] \s 匹配任意空白字符， 相当于 [ \t\n\r\f\v] \S 匹配非空白字符，相当于 [^ \t\n\r\f\v] \w 匹配数字、字母、下划线中任意一个字符， 相当于 [a-zA-Z0-9_] \W 匹配非数字、字母、下划线中的任意字符，相当于 [^a-zA-Z0-9_] ###正则表达式以及group的用法]]></content>
      <categories>
        <category>毕业设计</category>
      </categories>
      <tags>
        <tag>正则</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer(斐波那契数列)]]></title>
    <url>%2F2020%2F02%2F17%2F%E5%89%91%E6%8C%87offer(%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91)%2F</url>
    <content type="text"><![CDATA[避免递归造成的调用栈消耗 1234567891011public class Solution &#123; public int Fibonacci(int n) &#123; int a = 0; int b = 1; while(n--&gt;0)&#123; b = a + b; a = b - a; &#125; return a; &#125;&#125; 复杂度时间复杂度：O(n)O(n)空间复杂度：O(1)O(1)]]></content>
  </entry>
  <entry>
    <title><![CDATA[剑指offer(2)]]></title>
    <url>%2F2020%2F01%2F22%2FJava%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F%E5%89%91%E6%8C%87offer(2)%2F</url>
    <content type="text"><![CDATA[请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。 123456789101112131415161718192021222324252627282930313233343536public class Solution &#123; public String replaceSpace(StringBuffer str) &#123; String str1 = str.toString(); if(str1.equals(&quot;&quot;)) &#123; return(str1); &#125; char [] strArray = str1.toCharArray(); int lengthSpace = 0; for(int i = 0;i&lt;strArray.length;i++) &#123; if(strArray[i]==&apos; &apos;) &#123; lengthSpace++; &#125; &#125; int newStrLength = strArray.length + lengthSpace*2; char [] newstrArray = new char[newStrLength]; int count = 0; for(int i = 0;i&lt;strArray.length;i++) &#123; if(strArray[i]!=&apos; &apos;) &#123; newstrArray[i+count*2] = strArray[i]; &#125; else&#123; newstrArray[i+2*count]=&apos;%&apos;; newstrArray[i+2*count+1]=&apos;2&apos;; newstrArray[i+2*count+2]=&apos;0&apos;; count++; &#125; &#125; return new String(newstrArray); &#125;&#125; 12345public class Solution &#123;public String replaceSpace(StringBuffer str) &#123;return str.toString().replaceAll(&quot;\\s&quot;, &quot;%20&quot;);&#125;&#125; 题解：如果建新数组的话，从后往前还是从前往后都是一样的。??? charAt(),deleteCharAt() s1.charAt(3); s1.deleteCharAt(3); setCharAt();替换所引出的char值 str.setCharAt(indexnew, ‘0’); append(); StringBuffer s1 = new StringBuffer().append(“bbb”); s1.append(“aaa”); System.out.println(s1.toString()); replace两种用法： replace(int start，int end, String str)replace(char oldchar, char newchar) toString() toCharArray() StringBuffer s1 = new StringBuffer();s1.toString();String s2 = new String();s2.toCharArray(); delete(); insert(); indexOf(); lastIndexOf(); reverse(); length();indexOf()返回指定字符串的开始字符索引位置，还可以从某个字符索引位置开始向后匹配，没有找到匹配的就会返回-1lastIndexOf()是从后往前匹配，也支持从指定索引开始从后往前去匹配 s1.delete(2,4);s1.insert(2,”cc”);System.out.println(s1.indexOf(“ba”));System.out.println(s1.indexOf(“ba”,2));System.out.println(s1.reverse());System.out.println(s1.length()); String,StringBuffer,StringBuilder三者的使用方法和区别String适用于少量的字符串操作的情况StringBuilder适用于单线程下在字符缓冲区进行大量操作的情况StringBuffer适用多线程下在字符缓冲区进行大量操作的情况 一.java数据类型1.基本数据类型byte(1) boolean(1) short(2) char(2) int(4) float(4) long(8)double (8)2.引用数据类型string,数组，集合ArrayList,Scanner,Random,自定义类型3.引用类型String中的方法第一组：判断方法boolean equals(String str); //比较两个字符串是否相等boolean equalsIgnoreCase(String str); //比较两个内容是否相等 （忽略大小写）boolean startsWith(String subStr); //判断某个字符串是否以指定的子串开头boolean endsWith(String subStr); //判断某个字符串是否以指定的子串结尾第二组：获取方法int length();//获取字符串中字符个数char charAt(int index); //获取字符串中某一个字符String substring(int startIndex);//从指定下标开始截取字符串，直到字符串结尾substring(int startIndex,int endIndex); //包括开头不包括结尾？int indexof(String subStr); //获取子串第一次出现的下标第三组：转换方法String toLowerCase(); //转成小写串String toUpperCase); //转成大写串Char[] toCharArray(); //变成字符数组第四组：其他方法String trim();//去掉字符串两端的空格String[] split(String str); //切割字符串三：读写文件输出流：数据从java程序 到 文件中FilWriter：文件的字符输出流，写数据 （一个字符，一个字符串，一个字符数组） write(int ch);// 写一个字符 write(char[] chs); //写一个字符数组 write(String s);// 写一个字符串 write(char[] chs,int startInex,int len);// 写一个字符数组的一部分 write(String s,int startInex,int len); //写一个字符串的一部分输入流：数据从文件 到 java程序中FileReader:文件的字符输入流,读数据（一个字符，一个字符数组） int read();//读取一个字符 ASCII int read(char[] chs); //一次读取一个字符数组，返回值是读取的字符的个数文件的路径分为两种：1.相对路径：相对于当前项目而言的 2.绝对路径：以盘符开头]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础学习1]]></title>
    <url>%2F2020%2F01%2F04%2FJava%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2Fjava%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01%2F</url>
    <content type="text"><![CDATA[类的概念： 一堆具有共同的成员变量、属性和成员方法、功能对象集合 接口的概念： 接口是功能的集合，就是方法的集合 也就是说 接口中只能定义方法，不能定义普通的成员变量 而且接口中的成员方法，必须都是抽象的 接口是比抽象类还要抽象的一种类型 问题：接口能创建对象吗？不能接口作用：天生作为“父接口” 接口的定义： 定义接口用关键字：interface 定义枚举用关键字：enum 格式： public interface 接口名字{ //成员变量，不能定义普通的成员变量 //成员方法：必须都是抽象 public abstract 返回值类型 方法名(); } 类和接口的本质区别不大，他们的源码都是.java文件 编译后都是.class文件 类与类之间：继承，而且是单继承，一个子类，只能有一个直接父类 接口和接口之间:继承，但是可以多继承，一个子接口 可以有多个直接父接口 面试题：Java到底支不支持多继承？ 如果是类与类 不支持多继承 只支持多层继承 如果是接口和接口 支持多继承 也支持多层继承 类和接口之间：不叫继承(extends),叫实现(implements),可以多实现 只有类 实现接口 接口中成员的特点 5.1成员变量，但是必须有固定修饰符public static final 数据类型 变量 = 值 5.2成员方法，必须是固定修饰符public abstract 即抽象方法 5.3接口不可以创建对象(抽象类也是) 5.4实现类 实现类接口，那么必须重写接口中所有的抽象方法，然后才能创建对象否则 这个实现类 还是一个抽象类，是不能创建对象的 在开发中最常用的模式： public class A extends AbstractClassB implements 接口A，接口B{ 注意： A中必须重写 抽象类中的抽象方法，以及所有接口中的抽象方法 } 接口和抽象类的异同：1.相同点： a.都不能创建对象 b.都是作为父类/父接口 c.子类/实现类 都必须重写抽象方法，然后才能创建对象2.不同点： a.抽象类用关键字abstract 接口用关键字interface b.接口中只要有方法，必须都是抽象的 c.抽象类可以定义任意成员变量 接口的成员变量必须public static final修饰 d.类和抽象类之间关系是单继承，类和接口之间关系是多实现 e.思想上的区别 1.抽象类中必须定义整个继承体系中的共性内容 2.接口中定义 整个继承体系之外的 额外扩展的功能。 7.面向对象3大特征：封装(安全性)，继承(扩展性)，多态(灵活性) 多态： 前提1.必须有子父类关系 2.必须有方法的重写 多态在Java中的表现形式： 父类类型 变量名 = new 子类类型(); 接口类型 变量名 = new 实现类(); Animal an = new Cat(); 父类类型的变量指向了子类的对象 注意： 1.使用多态调用成员变量 编译时，看父类 运行时，看父类 2.使用多态调用成员方法 编译时，看父类 运行时，看子类总结： 弊端：多态只能调用子父类共有的方法，不能调用子类特有的方法 好处：提高灵活性 父类类型的变量，可以接收任何一个子类的对象 调用方法的时候，编译是看父类，运行时运行的传递过来的子类对象的方法 弊端的解决方案： 向下转型：强制类型转换 向上转型：自动类型转换 (就是多态) 向下转型也有弊端： 把父类的变量 转成任何子类类型时候，编译器直接通过 可以转成cat,本质是dog 所以出错 Java中解决向下转型弊端的方法： 一个关键字Instanceof 运算符 作用：判断某一个变量 不是 该类的类型 格式： boolean b = an instanceof 类名 多态提高程序的灵活性，扩展性，复用性。 static的介绍: static的作用用来修饰类中的成员 1.如果一个类的成员被static修饰了，怎么访问？ 类名.成员变量名 存在方法区中的静态区，只有一个空间 优先于对象存在 2.类名.成员变量(推荐) 对象.成员变量 都可以 3.所有对象共有的，被staic修饰的成员属于类，不属于单个对象 4.静态没有多态性 静态不属于对象，属于类 5.静态代码块：在类的成员位置 static{ 代码 } 特点： 使用到这个类时，JVM会自动执行静态代码块 只会第一次使用时执行 优先级比构造方法高，比main方法高 作用：用来初始化类的,myswl数据(静态代码块来加载驱动) final可以修饰 类，成员变量，成员方法，局部变量(基本类型，引用类型) 1.修饰类(太监类)，不能被继承 2.final修饰成员变量: 2.1必须在创建对象之前有却确定的值 2.3只能赋值一次 3.修饰方法: 不能被子类重写 4.修饰基本类型局部变量 被final修饰的基本类型局部变量 只能赋值一次 5.修饰引用类型局部变量 被final修饰的引用类型局部变量 只能赋值一次 但是引用类型所指向的对象中内容是可以改变的 匿名内部类：是一种特殊的语法，用来快速创建抽象类的子类对象 用来快速创建 接口的实现类对象 AbstractAnimal an1 = new AbstractAnimal(){ 重写 } 多态 引用数据类型a.类作为方法的参数或者返回值(我们需要传递或返回的是该类的对象)b.抽象类作为方法的参数和返回值 (和9结合起来)我们需要传递或返回的是该抽象类的子类的对象c.接口作为方法的参数和返回值 (我们需要传递或返回的是该接口的实现类的对象) 链式编程 权限修饰符如果一个成员只想在本类中使用 用private修饰如果一个成员想在本类和本包的其它类中使用 不写 default如果一个成员想在本类，本包，其他包的子类中使用 用protected修饰如果一个成员想在所有类中使用 用public修饰 Object类：类Object是类层次结构的根类所有类都必须直接或者间接的继承object boolean equals(Object obj);p1.equals(p2);//比较两个对象是否相等,在Object类中定义equals方法比较是 两个对象的地址在String类中 重写了object父类中的equals方法， 本来在object类中比较的是两个对象的地址 在String重写后变成比较两个字符串的内容 我们程序员 通常自定义一个类 也会重写equals toString(); //返回该对象的字符串表示 Object类中的默认的返回值：包名.类名@地址 实际开发中toString的使用，重写toString 返回对象中的成员变量 异常:是java代码编译或者运行过程中异常的继承体系:Throwable(异常和错误的超类):可以抛出去的东西 --Exception:异常(普通问题) --编译时异常: 指的是Exception 以及Exception子类 (除了RuntimeException) --运行时异常: RuntimeException以及其子类 --Error:错误(严重问题) 比如:OutOfMemoryError:超出内存错误 如果程序出现了错误，只能改代码 创建异常对象，对异常的基本操作：1.抛出异常 2.处理异常(捕获异常，将异常获取，使用try/catch做分支处理)JVM默认处理异常的方式:(中断处理)处理异常的方式：1.不处理 public 返回值类型 方法名(参数)throws xxxException{ } 2.捕获处理 try{ 可能出现的异常的代码 }catch(Exception e){ //处理异常 }finally{ //写上必须要执行的代码 //释放资源的代码 } 3.其他的处理方式 多个异常分别处理 多个个异常一次捕获多次处理 多个异常一次捕获一次处理 父类方法没有抛出异常，子类覆盖父类该方法时也不可抛出异常。此时子类产生该异常，只能捕获处理。打印异常信息:printStackTrace1.RuntimeException2.ClassCastException 类型转换异常(向下转型的时候)3.ArrayIndexOutOfBoundsException 数组下标越界4.StringIndexOutOfBoundsException 字符串下标越界自定义异常类：1.创建一个类，这个类必须用Exception结尾2.必须继承Exception 或者 RumtimeException3.自定义的异常 至少有两个构造 a.空参数构造 b.带有String类型参数构造 Object类:是所有类的根类boolean equals(Object obj)a.Object类中equals方法,比较是两个对象的地址，就是==号的作用b.重写 比较两个字符串的内容 比较两个对象的成员变量的值String toString();//返回该对象的字符串表示 hashCode()返回该对象的数字表示 什么叫设计模式？把解决问题的方案 总结出一个套路1.代理设计模式1.1静态代理设计模式1.2动态代理设计模式 date类:日期类表示特定的瞬间，精确到毫秒 public Date(); //无参构造public Date(long time);1.DateFormat是一个抽象类 我们不能用它2.我们使用它的一个子类：SimpleDateFormatSimpleDateFormat:简单的日期格式化类1.构造public SimpleDateFormat(String pattern);//以指定的模式 创建一个日期格式化对象 2.成员方法public String format(Date d);//格式化一个日期对象，返回格式化后的一个字符串 public Date parse(String s);//把一个字符串形式的日期，解析成Date对象 Calender类获取Calendar的子类对象获取Calender对象的某个字段 (get) System类它不能被实例化，因为构造方法私有化了而且System类中的方法都是静态的，通过类名就可以直接访问System.exit(0); //退出JVMpublic static void gc(); //运行java的垃圾回收器(并不是马上运行)public static String getProperty(String ProertyName);//获取某一个属性的值public static long currentTimeMillis();//获取当前系统的毫秒值 String(不可变) StringBuilder(可变)//当出现大量的字符串拼接运算 时 用StringBuilder 基本数据类型 对应的引用类型int Integer拆箱：包装类型—&gt;基本类型装箱：基本类型—&gt;包装类型 正则表达式： javac 生成编译文件 java 执行类文件，出错原因java程序运行class文件,对于有包名的类,java把包名当成文件夹处理.”包名+类名”相当于”文件夹目录+类名”来寻找类。 b = a++ a先赋值，再自增。 mysql Orcale DB2(银行系统) SQLite(手机端) SQLServer SyBase(建模工具PowerDesigner)]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[考研]]></title>
    <url>%2F2019%2F03%2F24%2F%E8%80%83%E7%A0%94%2F</url>
    <content type="text"><![CDATA[失败不是终点，找好工作再说8]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汇编语言]]></title>
    <url>%2F2019%2F02%2F25%2F%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%2F</url>
    <content type="text"><![CDATA[指令系统数据寻址方式: CPU: 立即寻址方式 寄存器寻址方式 存储器： 直接寻址方式 间接寻址方式 相对寻址方式]]></content>
  </entry>
  <entry>
    <title><![CDATA[Java学习笔记2]]></title>
    <url>%2F2019%2F02%2F11%2FJava%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2Fjava%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03%2F</url>
    <content type="text"><![CDATA[io 多线程 网络编程 XML IO流 1.字符流,字节流 字符输入流：共同的父类Reader 比如FileReader,BufferedReader 功能：读取一个字符，读取一个字符数组(一部分)，读取一个字符串 字符输出流：共同的父类Writer 比如FileWriter,BufferedWriter 功能：写一个字符，写一个字符数组(一部分)，写一个字符串 字节输入流：共同父类 InputStream 比如：FileInputStream,BufferInputStream 读取一个字节 读取一个字节数组 字节输出流：共同父类 OutputStream 比如：FileOutputStream,BufferOutputStream 写一个字节 写一个字节数组 2.OutputStream:字节输出流的根类，这是一个抽象类 public void close(); public void flush(); //刷新流 public void write(int b); //写一个字节 public void write(byte[] bs); //写一个字节数组 public void writre(byte[] bs,int startIndex, int lenght);//写一个字节数组的一部分 3.续写和换行 FileOutputStream fos = new FileOutputStream(“2.txt”,true); fos.write(“\r\nhello”.getBytes()); fos.close(); 4.InputStream:字节输入流的根类，这是一个抽象类 1.public int read();、、读取一个字节，返回是码值 2.public int read(byte[] bs);//读取一个字节数组，返回值表示实际读取到的字节数 我们用InputStream具体子类：FileInputStream 一次读取一个字节 FileIntputStream fis = new FileIntputStream(new File(“1.txt”)); int b = 0; while(b=fis.read()!=-1) { System.out.println((char)b); } fis.close(); 一次读取一个字节数组 byte[] bs = new byte[4]; int len = fis.read(bs); System.out.println(len); //实际字节数 System.out.println(new String(bs)); 标准： while((len = fis.read(bs)!=-1)) { System.out.println(new String(bs,0,len)) } 复制文件： long s= System.currentTimeMillis(); //系统时间 while((len = fis.read(bs)!=-1)) { fos.writ(bs,0,len); } 字节缓冲流： BufferedOutputStream bos = new BufferedOutputStream(new FileOutputaStream(“1.txt”)); 字节流读取中文的乱码问题：读取中文读了一半 解决问题：字符流 转化流 字符编码表(字符集) ASCII码表 在GBK码表中一个中文2个字节 在UTF-8中一个中文 3个字节 OutputStreamWriter 是字符流通向字节流的桥梁，查码表(编码) OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(“1.txt”)); osw.close(); 字节-&gt;解码-&gt;字符： InputStreamReader 字符-&gt;编码-&gt;字节： OutputStreamWriter transient关键字： 用来修饰成员变量 用不用没有影响 序列化的时候有用，如果一个成员变量被transient修饰，那么序列化的时候会忽略该成员变量 static:关键字 他也具有和transient一样的功能 打印流： PrintWriter:打印字符流 PrintyStream:打印字节流 使用第三方框架的步骤 1.导入classpath a.在工程根目录下 建立一个目录”lib” b.把要使用的第三方框架的jar包拷贝过来 c.添加构建路径 右键单击jar包—-&gt;Build Path —-&gt; Add to Build Path 以FileUtils为例 多线程 内存RAM 硬盘ROM多线程程序并不能提高程序的运行速度，但能够提高程序运行速率，让cpu的使用率更高。main方法所在线程 我们就称为主线程Thread类：线程类public Thread();//创建一个默认名字的线程对象public Thread(String name);//创建一个指定名字的线程对象第一种：继承class 子线程类 extends Thread{ run(){任务代码 }}子线程类 t = new 子线程类();t.start();第二种：声明实现Runable接口的类，重写run方法，创建实现类对象，创建Thread对象，并把刚刚的实现类对象 作为参数传递，启动这个Thread对象从耦合性分析用第二种扩展性:第一种继承Thread，那么子线程类就不能继承别的类第二种方式 由于是实现了接口，同时可以继承别的类匿名内部类创建线程对象 new Thread(){ public void run(){///////// }}.start(); new Thread(new Runnable(){ public void run(){///// }}).start();线程安全问题：1.同步锁 synchronized(obj)2.同步方法:public synchronized void sale(){}这里同步方法使用的锁对象 叫做this对象这里同步方法是静态方法，那么他的锁对象是当前类.class3.lock接口方式实现类：ReentrantLock 网络编程 udp tcp InetAddress XML语法 文档说明： &lt;?xml version=”1.0 encoding=”TTF-8”?&gt; 作用：存放数据 配置文件 CDATA区 &lt;![CDATA[]]&gt;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python爬虫初学]]></title>
    <url>%2F2019%2F02%2F09%2Fpython%E7%88%AC%E8%99%AB%E5%88%9D%E5%AD%A6%2F</url>
    <content type="text"><![CDATA[#coding:utf-8 #author:Ericam_ 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344import reimport sysfrom bs4 import BeautifulSoupimport urllib.requestimport timeheaders = (&apos;User-Agent&apos;, &apos;Mozilla/5.0 (iPhone; CPU iPhone OS 9_1 like Mac OS X) AppleWebKit/601.1.46 (KHTML, like Gecko) Version/9.0 Mobile/13B143 Safari/601.1&apos;)opener = urllib.request.build_opener()opener.addheaders = &#123;headers&#125;urllib.request.install_opener(opener)def get_download(url): file = urllib.request.urlopen(url) data = BeautifulSoup(file , from_encoding=&quot;utf8&quot;) section_name = data.title.string print(section_name) section_text = data.select(&apos;#content #left font&apos;)[0].text section_text=re.sub( &apos;\s+&apos;, &apos;\r\n\t&apos;, section_text).strip(&apos;\r\n&apos;) fp = open(&quot;D:/python/2.txt&quot;,&apos;a&apos;,encoding=&apos;utf-8&apos;) fp.write(section_name+&apos;\n&apos;) fp.write(section_text+&apos;\n&apos;) fp.close()if __name__ == &apos;__main__&apos;: url = &quot;http://www.net767.com/shuji/fubaba/10995.html&quot; while(True): file = urllib.request.urlopen(url) data = BeautifulSoup(file , from_encoding=&quot;utf8&quot;) section_name = data.title.string print(section_name) section_text = data.select(&apos;#content #left font&apos;)[0].text section_text=re.sub( &apos;\s+&apos;, &apos;\r\n\t&apos;, section_text).strip(&apos;\r\n&apos;) print(section_text) txt_section=data.select(&apos;#pagebar a&apos;) l1=len(txt_section) for num in range(1,l1-1): y=txt_section[num][&apos;href&apos;] url = &quot;http://www.net767.com&quot;+y get_download(url) print(y) txt2_section=data.select(&apos;.LinkNextArticle&apos;) y2=txt2_section[0][&apos;href&apos;] url = &quot;http://www.net767.com&quot;+y2 if(url == &apos;http://www.net767.com/shuji/fubaba/11003_9.html&apos;): break print(y2)]]></content>
  </entry>
  <entry>
    <title><![CDATA[Java学习笔记2]]></title>
    <url>%2F2019%2F02%2F08%2FJava%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2FJava%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02%2F</url>
    <content type="text"><![CDATA[项目（秒杀系统） 集合(collection)： 数组的长度是固定的，集合的长度是可变的。 每一个容器的数据结构不一样 Collection接口定义着集合框架中最最共性的内容 size(); add(); remove(); clear(); contains(); toArray(); 集合的遍历： 在根接口中使用了一种公共的遍历方式，迭代器遍历 获取一个集合的迭代器对象(迭代器对象不是我们创建的，而是每个集合自带的) 是一个接口 12345Iterator&lt;String&gt; it = names.iterator();while(it.hasnext())&#123; String s = it.next(); System.out.println(s);&#125; java规定，如果一个集合使用迭代器遍历，那么遍历的过程中，不允许修改集合长度 增强for循环Collection names = new ArrayList();for(数据类型 变量名：数组/集合){ syso(变量名);}使用增强for循环遍历集合的时候，不能修改集合的长度 泛型:E实际上是一个“变量” 用来保存一种数据类型 ,&lt;K,V&gt; 可以用在类，方法，接口上。 泛型通配符 ？：代表任意类型 Collections.shuffle(cards); //洗牌 栈，队列数组结构 Arraylist Vector 查询快，增删慢链表结构：一般使用双向链表哈希表结构：查询快 增删快 List接口特点：有下标，有序的，可重复实现类：ArrayList,LinkedList,Vector 安全List结构中的方法：增：add(E e); add(int index,E e)删：remove(Object obj);remove(int index);改：set(int index,E e);查：get(int index);其他： size();clear(),contains(Object obj),toArray(); iterator();isEmpty();1.ArrayList:方法基本和List一致 2.LinkedList:还有大量的首尾操作方法void addFirst(E e);E removeFirst();E getFirst();E pop(); 和removeFirst一致void push(E e); 推入 和addFirst一致 Set接口a.无下标b.无序的c.不可重复实现类：HashSet：底层采用哈希表结构，查询快，增删快，无序的LinkedHashSet:链表＋哈希表，查询快，增删快，有序Set接口中的特有方法和Collection基本一致TreeSet:红黑树 哈希表哈希值：每一个对象都具有哈希值地址值实际是哈希值的16进制String对象的哈希值：重写了Object类中的hashCode不再通过地址值计算 只和字符串内容相关哈希表结构，添加元素判断是否重复1.先判断新旧元素的哈希值2.再判断新旧元素的equals自定义类，要使用HashSet存储保证元素唯一性： 必须重写自定义类的两个方法 hashcode equals定义一个标准得类：1.封装2.构造3.toString4.hashCode equalscontains方法：ArrayList:names.contains(“abc”);HashSet:set.contains(“abc”); Map接口Map&lt;K,V&gt;集合常用方法： 、HashMap增：put(K key,V value); //向集合中添加键值对//如果集合中已存在该键，覆盖整个键值对，并返回被覆盖的键值对的值判断k是不是空哈希表结构，添加元素判断是否重复1.先判断新旧元素的哈希值2.再判断新旧元素的equals删：v remove(object key); //返回被删除的键值对的值改：==put查：V get(K key); 判断是不是空Map集合遍历： LinkedHashMap HashMapgetKey();getValue();1.keySet遍历Set keys = students.keySet(); //放在set集合中map.KeySet(); Iterator hasnextfor(String key : keys){ String value = students.get(key);}2.Set&lt;Map.Entry&gt; entrySet = map.entrySet();Iterator&lt;Map.Entry&lt;String,String&gt;&gt; it = entrySet.iterator();while(it.hasNext(){ Map.Entry&lt;String, String&gt; entry = it.next(); String key = entry.getKey(); String value = entry.getValue(); system.out.println(key+”=”+value)；}) 123456789101112131415161718192021222324252627282930313233343536373839404142434445import java.util.HashMap;import java.util.Iterator;import java.util.Map;import java.util.Map.Entry;import java.util.Set; public class MapTest &#123; public static void main(String[] args) &#123; Map&lt;Integer, String&gt; map = new HashMap&lt;&gt;(); //map集合存入数据 map.put(1, &quot;第一个value&quot;); map.put(2, &quot;第二个value&quot;); map.put(3, &quot;第三个value&quot;); //通过keySet取出map数据[for-each循环] System.out.println(&quot;-------[for-each循环遍历]通过keySet取出map数据-------&quot;); Set&lt;Integer&gt; keys = map.keySet(); //此行可省略，直接将map.keySet()写在for-each循环的条件中 for(Integer key:keys)&#123; System.out.println(&quot;key值：&quot;+key+&quot; value值：&quot;+map.get(key)); &#125; //通过EntrySet取出map数据[for-each循环] System.out.println(&quot;-------[for-each循环遍历]通过EntrySet取出map数据-------&quot;); Set&lt;Entry&lt;Integer, String&gt;&gt; entrys = map.entrySet(); //此行可省略，直接将map.entrySet()写在for-each循环的条件中 for(Entry&lt;Integer, String&gt; entry:entrys)&#123; System.out.println(&quot;key值：&quot;+entry.getKey()+&quot; value值：&quot;+entry.getValue()); &#125; //通过keySet取出map数据[Iterator遍历] System.out.println(&quot;-------[Iterator循环遍历]通过keySet取出map数据---------&quot;); Iterator&lt;Integer&gt; it = map.keySet().iterator(); //map.keySet()得到的是set集合，可以使用迭代器遍历 while(it.hasNext())&#123; Integer key = it.next(); System.out.println(&quot;key值：&quot;+key+&quot; value值：&quot;+map.get(key)); &#125; //通过EntrySet取出map数据[Iterator遍历] System.out.println(&quot;-------[Iterator循环遍历]通过EntrySet取出map数据---------&quot;); Iterator&lt;Entry&lt;Integer, String&gt;&gt; iterator = map.entrySet().iterator(); //map.entrySet()得到的是set集合，可以使用迭代器遍历 while(iterator.hasNext())&#123; Entry&lt;Integer, String&gt; entry = iterator.next(); System.out.println(&quot;key值：&quot;+entry.getKey()+&quot; value值：&quot;+entry.getValue()); &#125; &#125; &#125; 内部类：OutClass.InterClass ic = new OutClass.new InterClass();内部接口 实现谁，重写谁如果Map中的键是自定义类型，那么要保证键的唯一性，必须重写键对应类的hashCode和equals方法3.Properties类本质就是一个Map集合持久的属性集ps.store(new FileWriter(“phones.properties”),””);//存ps.load(new FileReader(“phones.properties)); //读取没有泛型具有Map接口的一切方法，以及自己特有的getProperty();setProperty();public Set stringPropertyNames();//和KeySet一样Properties ps = new Properties();可变参数：public static int add(int…a){ return 0;}//类型不能改变，多个参数时，可变参数在最后面本质：数组 for(int i : a)Collections：(集合工具类)中的静态方法：public static void shuffle(List list);//打乱顺序public static void sort(List list);//把集合元素按照自然顺序排序Arrays:数组工具类public static List asList(数组/可变参数); //把数组转化为List集合Arrays.sort(nums);Arrays.toString(nums);Map集合的嵌套： File类 File类可以表示文件 也可以表示文件夹构造： 1.public File(String filepath); 绝对路径：以盘符开头的路径 相对路径：相对当前项目的根目录 2.public File(String parent ,String child); 3.public File(File parent,String child); File对象的获取方法public String getAbsolutePath();//获取绝对路径getName(); getPath();public long length(); //获取File对象(文件)的字节数 不能计算文件夹 File对象的删除和创建方法：1.创建方法 创建文件：public boolean creatNewFile(); //创建新的文件 创建文件夹public boolean mkdir(); 2.判断方法 判断是否是文件public boolean isFile(); 判断是否是文件夹public boolean isDirectory(); 判断是否存在public boolean exists(); 3.删除public boolean delete(); 4.File类下的list和listFiles方法(文件夹) 1.public String[] list(); 2.public File[] listFiles(); 只能列出当前文件下的一级子文件或者子文件夹 扩展：删除先删文件再删文件夹5.递归打印目录下的所有文件6.文件过滤器：FileFilter在list和listFiles方法中使用]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript学习笔记]]></title>
    <url>%2F2019%2F01%2F21%2Fjavascript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[参考菜鸟教程进行学习 javascript用法：HTML 中的脚本必须位于 与 标签之间。脚本可被放置在 HTML 页面的 和 部分中，也可以保存在外部文件中（则不需要加标签）。 输出： 使用 window.alert() 弹出警告框。 使用 document.write() 方法将内容写到 HTML 文档中。 使用 innerHTML 写入到 HTML 元素。 使用 console.log() 写入到浏览器的控制台。 var y; var z; var d; x=document.getElementsByClassName("Barrage-listItem"); y=document.getElementById(x[0].id); d=y.getElementsByTagName("div"); var reg = /Barrage-userEnter/i; console.log(reg.test(d[0].className)); console.log(d[0].className); if(reg.test(d[0].className)) { z=y.getElementsByTagName("span"); console.log(z[2].title); d[0].className="b"; }]]></content>
  </entry>
  <entry>
    <title><![CDATA[个人随笔]]></title>
    <url>%2F2019%2F01%2F20%2F%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94%2F</url>
    <content type="text"><![CDATA[1月20记 好久没有写日记了，下午和从小长大的朋友聊了会天，真的感觉时间过的好快。而且似乎到了什么年龄，周围的人就会询问关心你这个年龄应该干的事情做的怎么样。就好像上学期间就是学校的好坏，工作期间就是结婚工资。那么究竟你是变得更好还是会更烂呢？ 考研信息，结课作业。1.21到1.25 英语单词，阅读。寒假每天坚持 线代复习，真题。寒假每天坚持视频每天3个，加看辅导书。 javascrip,css,html。 python,爬虫项目。 1.28到2.2 实验室论文，深度学习。 2.2以后 小程序项目 1.28到2.2 java 2.2以后前三个尽量做完，4，5，7完成一二即可，6，8能入门就再好不过了。 其他： 旅游（估计难了 555） 联系一下朋友同学 （加油嗷） 吃饭，作息规律 （一定可以的） 读完3本书 (穷爸爸，富爸爸 如何阅读一本书 自控力) 想到的再继续补充~ 2.8到2.20（11天） 线代每天两个视频，辅导讲义写完 3 英语一个单元 2.5（课听完） 看书1个小时 查考研信息 问问问 健身刷牙 python斗鱼的项目 小程序的项目 #抛弃浮躁，脚踏实地。 英语： 单词： 高频单词视频看完 （2月之前） 每天1个list背诵 空闲时间刷百词斩 阅读： 3.4月份：08年之前的真题阅读精读（一天一篇）+网课学习 暂定3个小时 5，6，7 做完所有真题阅读 8，9，10 作文，翻译，完型 暂定数学： 线代： 两天一章，视频+讲义+课本看完（2月底） 暂定暑假过第二遍 高数： 3，4月刷高数18讲+书+记笔记（第一遍） 后来暂定 概率论： 5或6月份专业课： 大概确定院校！！！ 背书 真题政治： 9月份大纲确定开始 时间安排：（暂定，根据具体情况会调整） 6：30~6：40洗漱 6：40~7：00吃早饭 7：10~8：00背单词 8：00~12：00 12：00~12：20吃饭 12：20~1：10休息 1：30~4：30 4：40~5：30健身 5：30~5:50吃饭 6：00~6：20洗澡 6：30~11:00 11:00~11:30洗漱，处理部分事情，睡觉 补充： 根据上课的时间进行有效调整 最重要的是把每天的任务计划都要提前列出来并且完成 咨询考研相关信息（学校，实验室，导师，考研参考书，学习方法，有效途径，询问学长学姐老师同学）放在中午12：00~1：30，4：30~6；30，11：00以后 其他时间不要看！！！ 3.8 7点起来 洗漱，吃饭。 8点到9点背单词和句子 9点到11点看英语视频 11点去吃饭+问王伟考研学校+专业课考什么 2点到4：30点看线代视频 4：30~6：30 健身，吃饭，洗澡 6：30~10：00 高数 买参考书]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo+github搭建博客]]></title>
    <url>%2F2019%2F01%2F19%2Fhexo-github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[序 搭建博客的过程教程很多，我也是参照网上的教程搭建的博客。搭建博客已经过去半年了，但是自己这么久却没有写这篇博文，多说无益，希望能从这篇博客开始先记录hexo博客的问题以及解决方法然后能坚持下去将自己所学所见记录下来，也作为自己生活学习的一个监督和记录。 搭建步骤： GitHub创建个人仓库（名称与用户名一致） git安装，绑定github密钥 git config –global user.name “你的GitHub用户名”git config –global user.email “你的GitHub注册邮箱” 生成ssh密钥文件： ssh-keygen -t rsa -C “你的GitHub注册邮箱” 打开GitHub_Settings_keys 页面，新建new SSH Key 安装node.js，npm 安装hexo： npm install -g hexo-cli 博客初始化： hexo init blog 查看本地localhost是否成功 修改.yml站点配置文件，绑定github 绑定域名 在blog\source下新建CNAME文件（无文件名）,例如： XXX.top 域名解析：建立CNAME解析，主机名分别为@和www，对应值都是你的 Github 个人主页地址 最后hexo g,hexo d,就ok辣。 命令介绍npm install hexo -g #安装Hexonpm update hexo -g #升级hexo init #初始化博客hexo n “我的博客” == hexo new “我的博客” #新建文章hexo g == hexo generate #生成hexo s == hexo server #启动服务预览hexo d == hexo deploy #部署hexo server #Hexo会监视文件变动并自动更新，无须重启服务器hexo server -s #静态模式hexo server -p 5000 #更改端口hexo server -i 192.168.1.1 #自定义 IPhexo clean #清除缓存，若是网页正常情况下可以忽略这条命令 踩过的坑首先第一次搭建完成后，遇到了61行date的问题 ，一直没有解决，所以我选择了再次搭建，并且将此过程记录了下来。 使用hexo命令显示无效注意需要在blog文件下进行操作还有congig.yml 空格问题基本新手都会犯 执行hexo命令出现ERRORnpm install 即可 前面都没有问题到了hexo d时候连接不上git所以不应用http 应该使用git 本地命令成功 但是localhost:访问不到网址大概率是端口占用了 本地可以访问但是用户名加github.io无法访问注意库名与用户名一致!!! 下载主题出现代理的问题 查询是否使用代理： git config –global http.proxy 取消代理： git config –global –unset http.proxy ERROR Process failed: about/index.mdTypeError: Cannot read property ‘utcOffset’ of null折腾了半天发现原来站点的配置文件的timezone也就是时区必须要和主题的的配置文件一直，把这两个文件下的timezone都设为Asia/Shanghai就解决了 Cannot GET/xxx查看index.html文件是否还在，可以参考这个 附加功能： 1.打赏 准备支付宝和微信二维码 在_config.yml中配置图片 reward_comment: 坚持原创技术分享，您的支持将鼓励我继续创作！wechatpay: /images/wechat.jpgalipay: /images/aipay.png wechat.jpg、alipay.png图片放入themes/next/source/images(主题配置)中 （解决文字闪烁问题）修改next/source/css/_common/components/post/post-reward.styl，注释wechat:hover和alipay:hover]]></content>
  </entry>
</search>
